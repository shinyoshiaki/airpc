{"version":3,"file":"redux.js","sourceRoot":"","sources":["../../src/redux.ts"],"names":[],"mappings":";;AAEA,MAAM,SAAS;IACb,YAAY,MAAW;QACrB,MAAM,CAAC,mBAAmB,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;YAC1D,IAAI,IAAI,KAAK,aAAa;gBAAE,OAAO;YACnC,MAAM,UAAU,GAAG,MAAM,CAAC,IAAI,GAAG,GAAG,GAAG,IAAI,CAAC;YAC5C,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,IAAI,EAAE,CAAC,CAAC;QACzD,CAAC,CAAC,CAAC;IACL,CAAC;CACF;AAED,SAAgB,SAAS,CAAI,MAA4B;IACvD,OAAO,IAAI,SAAS,CAAC,MAAM,CAAQ,CAAC;AACtC,CAAC;AAFD,8BAEC;AAED,SAAgB,WAAW,CAAgB,QAAW;IACpD,MAAM,MAAM,GAAG,CAAC,KAAU,EAAE,CAA8B,EAAc,EAAE;QACxE,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC;QACzB,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACvC,IAAI,QAAQ,CAAC,WAAW,CAAC,IAAI,KAAK,IAAI;YAAE,OAAO,KAAK,CAAC;QAErD,IAAI,QAAQ,CAAC,MAAM,CAAC,EAAE;YACpB,QAAQ,CAAC,KAAK,GAAG,KAAK,CAAC;YACvB,OAAO,QAAQ,CAAC,MAAM,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;SAClC;aAAM;YACL,OAAO,KAAK,CAAC;SACd;IACH,CAAC,CAAC;IACF,OAAO,MAAM,CAAC;AAChB,CAAC;AAdD,kCAcC;AAED,SAAgB,SAAS,CACvB,MAA6B,EAC7B,YAAe;IAKf,MAAM,QAAQ,GAAG,IAAI,MAAM,CAAC,YAAY,CAAC,CAAC;IAE1C,MAAM,OAAO,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC;IAClC,MAAM,MAAM,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC;IAErC,MAAM,OAAO,GAAG,CAAC,KAAK,GAAG,YAAY,EAAE,MAAW,EAAE,EAAE,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;IAE7E,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;AAC5B,CAAC;AAfD,8BAeC","sourcesContent":["import { Action } from \"./typings/action\";\n\nclass WrapRedux {\n  constructor(target: any) {\n    Object.getOwnPropertyNames(target.prototype).forEach(type => {\n      if (type === \"constructor\") return;\n      const actionType = target.name + \"_\" + type;\n      this[type] = (...args) => ({ type: actionType, args });\n    });\n  }\n}\n\nexport function wrapRedux<T>(target: { new (...args): T }): Action<T> {\n  return new WrapRedux(target) as any;\n}\n\nexport function exposeRedux<T extends any>(instance: T) {\n  const update = (state: any, v: { type: string; args: any }): T[\"state\"] => {\n    const { type, args } = v;\n    const [name, method] = type.split(\"_\");\n    if (instance.constructor.name !== name) return state;\n\n    if (instance[method]) {\n      instance.state = state;\n      return instance[method](...args);\n    } else {\n      return state;\n    }\n  };\n  return update;\n}\n\nexport function withRedux<A extends any, B>(\n  target: { new (state: B): A },\n  initialState: B\n): [\n  Omit<Action<A>, \"state\">,\n  (state: B | undefined, action: Omit<A[keyof A], \"state\">) => A[\"state\"]\n] {\n  const instance = new target(initialState);\n\n  const methods = wrapRedux(target);\n  const update = exposeRedux(instance);\n\n  const reducer = (state = initialState, action: any) => update(state, action);\n\n  return [methods, reducer];\n}\n"]}